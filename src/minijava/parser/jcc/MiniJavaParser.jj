options
{
  static = false;
}

// -----------------------------------------------------------------------------

PARSER_BEGIN(JCCMiniJavaParser)
package minijava.parser.jcc;

import java.util.ArrayList;
import minijava.ast.*;

public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

// -----------------------------------------------------------------------------

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
|  < "//" (~["\n", "\r"])* ("\n" | "\r")? >
}

// http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm#tth_sEc3.10
// When a /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
SKIP :
{
  "/*": IN_COMMENT
}
      
// When any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > SKIP :
{
  <  ~[] >
}
      
// When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP :
{
  "*/": DEFAULT
}

// -----------------------------------------------------------------------------

TOKEN : /* KEYWORDS */
{
  < CLASS   : "class" >
| < PUBLIC  : "public" >
| < STATIC  : "static" >
| < VOID    : "void" >
| < MAIN    : "main" >
| < STRING  : "String" >
| < EXTENDS : "extends" >
| < RETURN  : "return" >
| < IF      : "if" >
| < ELSE    : "else" >
| < WHILE   : "while" >
| < TRUE    : "true" >
| < FALSE   : "false" >
| < THIS    : "this" >
| < NEW     : "new" >
| < LENGTH  : "length" >
}

// -----------------------------------------------------------------------------

TOKEN : /* OPERATORS */
{
  < PLUS      : "+" >
| < MINUS     : "-" >
| < MULTIPLY  : "*" >
| < DIVIDE    : "/" >
| < EQUAL     : "=" >
| < AND       : "&&" >
| < LESS_THAN : "<" >
| < DOT       : "." >
| < NOT       : "!" >
}

// -----------------------------------------------------------------------------

TOKEN : /* SEPARATORS */
{
  < LPAR      : "(" >
| < RPAR      : ")" >
| < LBRACK    : "[" >
| < RBRACK    : "]" >
| < LBRACE    : "{" >
| < RBRACE    : "}" >
| < COMMA     : "," >
| < SEMICOLON : ";" >
}

// -----------------------------------------------------------------------------

TOKEN : /* METHODS */
{
  < PRINTLN : "System.out.println" >
}

// -----------------------------------------------------------------------------

TOKEN :
{
  < TYPE_INT       : "int" >
| < TYPE_BOOLEAN   : "boolean" >
//| < TYPE_INT_ARRAY : "int" (< LBRACK > < RBRACK >)? >
| < CONSTANT       : (< DIGIT >)+ >
| < IDENTIFIER     : < LETTER > (< LETTER > | < DIGIT > | "_")* >
| < #DIGIT         : [ "0"-"9" ] >
| < #LETTER        : [ "a"-"z", "A"-"Z" ] >
}

// -----------------------------------------------------------------------------

Program Program() :
{
  MainClass             mainClass;
  ClassDecl             c;
  ArrayList<ClassDecl>  otherClasses = new ArrayList<ClassDecl>();
}
{
  mainClass = Main()
  ( c       = ClassDeclaration() { otherClasses.add(c); } )*
              < EOF >
  { return new Program(mainClass, new NodeList<ClassDecl>(otherClasses)); }
}

// -----------------------------------------------------------------------------

MainClass Main() :
{
  Token     className,
            argName;
  Statement s;
}
{
              < CLASS >
  className = < IDENTIFIER >
              < LBRACE >
              < PUBLIC >
              < STATIC >
              < VOID >
              < MAIN >
              < LPAR >
              < STRING >
              < LBRACK >
              < RBRACK >
  argName   = < IDENTIFIER >
              < RPAR >
              < LBRACE >
  s         = Statement()
              < RBRACE >
              < RBRACE >
  { return new MainClass(className.image, argName.image, s); }
}

// -----------------------------------------------------------------------------

ClassDecl ClassDeclaration() :
{
  Token                 name,
                        superName = null;
  VarDecl               v;
  MethodDecl            m;
  ArrayList<VarDecl>    vars      = new ArrayList<VarDecl>();
  ArrayList<MethodDecl> methods   = new ArrayList<MethodDecl>();
}
{
  < CLASS >
  name = < IDENTIFIER >
  (
    < EXTENDS >
    superName = < IDENTIFIER >
  )?
  < LBRACE >
  (
    v = VarDeclaration(VarDecl.Kind.FIELD)    { vars.add(v); }
  | m = MethodDeclaration() { methods.add(m); }
  )*
  < RBRACE >
  { return new ClassDecl( name.image,
                          (superName != null) ? superName.image : null,
                          new NodeList<VarDecl>(vars),
                          new NodeList<MethodDecl>(methods)); }
}

// -----------------------------------------------------------------------------

VarDecl VarDeclaration(VarDecl.Kind kind) :
{
  Type  type;
  Token id;
}
{
  type  = Type()
  id    = < IDENTIFIER >
          < SEMICOLON >
  { return new VarDecl(kind, type, id.image); }
}

// -----------------------------------------------------------------------------

MethodDecl MethodDeclaration() :
{
  Type                  returnType;
  Token                 id;
  VarDecl               varDecl;
  Statement             s;
  ArrayList<VarDecl>    formals     = new ArrayList<VarDecl>();
  ArrayList<VarDecl>    vars        = new ArrayList<VarDecl>();
  ArrayList<Statement>  statements  = new ArrayList<Statement>();
  Expression            returnExp;
}
{
                < PUBLIC >
  returnType  = Type()
  id          = < IDENTIFIER >
                < LPAR >
  formals     = FormalList()
                < RPAR >
                < LBRACE >
  (
    LOOKAHEAD(2)
    varDecl   = VarDeclaration(VarDecl.Kind.LOCAL)  { vars.add(varDecl); }
  )*
  (
    LOOKAHEAD(2)
    s         = Statement()       { statements.add(s); }
  )*
                < RETURN >
  returnExp   = Expression()
                < SEMICOLON >
                < RBRACE >
  { return new MethodDecl(returnType,
                          id.image,
                          formals,
                          vars,
                          statements,
                          returnExp); }
}

// -----------------------------------------------------------------------------

ArrayList<VarDecl> FormalList() :
{
  Type                t;
  Token               id;
  ArrayList<VarDecl>  formals = new ArrayList<VarDecl>();
}
{
  (
    t   = Type()
    id  = < IDENTIFIER >
    { formals.add(new VarDecl(VarDecl.Kind.FORMAL, t, id.image)); }
    (
            < COMMA >
      t   = Type()
      id  = < IDENTIFIER >
      { formals.add(new VarDecl(VarDecl.Kind.FORMAL, t, id.image)); }
    )*
  )?
  { return formals; }
}

// -----------------------------------------------------------------------------

Statement Statement() :
{
  Token                 name;
  Expression            e1,
                        e2;
  Statement             s1,
                        s2;
  ArrayList<Statement>  statements = new ArrayList<Statement>();
}
{
          < LBRACE >
  ( s1  = Statement() { statements.add(s1); } )*
          < RBRACE >
  { return new Block(new NodeList<Statement>(statements)); }
|       < IF >
        < LPAR >
  e1  = Expression()
        < RPAR >
  s1  = Statement()
        < ELSE >
  s2  = Statement()
  { return new If(e1, s1, s2); }
|       < WHILE >
        < LPAR >
  e1  = Expression()
        < RPAR >
  s1  = Statement()
  { return new While(e1, s1); }
|       < PRINTLN >
        < LPAR >
  e1  = Expression()
        < RPAR >
        < SEMICOLON >
  { return new Print(e1); }
| LOOKAHEAD(2)
  name  = < IDENTIFIER >
          < EQUAL >
  e1    = Expression()
          < SEMICOLON >
  { return new Assign(name.image, e1); }
| name  = < IDENTIFIER >
          < LBRACK >
  e1    = Expression()
          < RBRACK >
          < EQUAL >
  e2    = Expression()
          < SEMICOLON >
  { return new ArrayAssign(name.image, e1, e2); }
}

// -----------------------------------------------------------------------------

Expression Expression() :
{ Expression e; }
{ e = AndExpr() { return e; } }

// -----------------------------------------------------------------------------

Expression BasicExpr() :
{
  Token       id;
  Expression  e;
}
{ id = < CONSTANT >   { return new IntegerLiteral(id.image); }
| < TRUE >            { return new BooleanLiteral(true); }
| < FALSE >           { return new BooleanLiteral(false); }
| id = < IDENTIFIER > { return new IdentifierExp(id.image); }
| < THIS >            { return new This(); }
| LOOKAHEAD(2)
        < NEW >
        < TYPE_INT >
        < LBRACK >
  e   = Expression()
        < RBRACK >
  { return new NewArray(e); }
|       < NEW >
  id  = < IDENTIFIER >
        < LPAR >
        < RPAR >
  { return new NewObject(id.image); }
|     < LPAR >
  e   = Expression()
      < RPAR >
  { return e; }
}

// -----------------------------------------------------------------------------

Expression AndExpr() :
{
  Expression e1,
             e2;
}
{
  e1 = LessThanExpr()
  (         < AND >
    e2 = LessThanExpr()
    { e1 = new And(e1, e2); }
  )*
  { return e1; }
}

// -----------------------------------------------------------------------------

Expression LessThanExpr() :
{
  Expression e1,
             e2;
}
{
  e1 = AddMinusExpr()
  (
         < LESS_THAN >
    e2 = AddMinusExpr()
    { e1 = new LessThan(e1, e2); }
  )*
  { return e1; }
}

// -----------------------------------------------------------------------------

Expression AddMinusExpr() :
{  Expression e1,
             e2;
}
{  e1 = MultExpr()
  (
         < PLUS >
    e2 = MultExpr()
    { e1 = new Plus(e1, e2); }
  |      < MINUS >
    e2 = MultExpr()
    { e1 = new Minus(e1, e2); }
  )*
  { return e1; }
}

// -----------------------------------------------------------------------------

Expression MultExpr() :
{  Expression e1,
             e2;
}
{  e1 = NotExpr()
  (         < MULTIPLY >
    e2 = NotExpr()
    { e1 = new Times(e1, e2); }
  )*
  { return e1; }
}

// -----------------------------------------------------------------------------

Expression NotExpr() :
{  Expression e;
  int numNots = 0;
}
{  (
    < NOT >
    { numNots++; }
  )*
  e = AccessorExpr()
  {
    for(int i = 0; i < numNots; i++)
    {      e = new Not(e);
    }
    return e;
  }
}
// -----------------------------------------------------------------------------

Expression AccessorExpr() :
{
  Expression  e1,
              e2;
}
{
  e1 = BasicExpr()
  (
    e1 = AccessorExprTail(e1)
  )*
  { return e1; }
}

// -----------------------------------------------------------------------------

Expression AccessorExprTail(Expression e) :
{
  Token                 id;
  Expression            e1,
                        e2;
  ArrayList<Expression> rands = new ArrayList<Expression>();
}
{
        < LBRACK >
  e1  = Expression()
        < RBRACK >
  { return new ArrayLookup(e, e1); }
| LOOKAHEAD(2)
  < DOT >
  (
    < LENGTH >
    { return new ArrayLength(e); }
  |
    id  = < IDENTIFIER >
          < LPAR >
          (
            e1 = Expression()
            { rands.add(e1); }
            (
              < COMMA >
              e2 = Expression()
              { rands.add(e2); }
            )*
          )?
          < RPAR >
    { return new Call(e, id.image, new NodeList<Expression>(rands)); }
  )
}

// -----------------------------------------------------------------------------

Type Type() :
{ Token t; }
{
  t = < TYPE_INT >
      (
        < LBRACK >
        < RBRACK >
        { return new IntArrayType(); }
      )?
      { return new IntegerType(); }
| t = < TYPE_BOOLEAN >  { return new BooleanType(); }
| t = < IDENTIFIER >    { return new ObjectType(t.image); }
}

