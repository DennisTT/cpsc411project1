options
{
  static = false;
}

// -----------------------------------------------------------------------------

PARSER_BEGIN(JCCMiniJavaParser)
package minijava.parser.jcc;

import java.util.ArrayList;
import minijava.ast.*;

public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

// -----------------------------------------------------------------------------

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

// -----------------------------------------------------------------------------

TOKEN : /* KEYWORDS */
{
  < CLASS   : "class" >
| < PUBLIC  : "public" >
| < STATIC  : "static" >
| < VOID    : "void" >
| < MAIN    : "main" >
| < STRING  : "String" >
| < EXTENDS : "extends" >
| < RETURN  : "return" >
| < IF      : "if" >
| < ELSE    : "else" >
| < WHILE   : "while" >
| < TRUE    : "true" >
| < FALSE   : "false" >
| < THIS    : "this" >
| < NEW     : "new" >
| < LENGTH  : "length" >
}

// -----------------------------------------------------------------------------

TOKEN : /* OPERATORS */
{
  < PLUS      : "+" >
| < MINUS     : "-" >
| < MULTIPLY  : "*" >
| < DIVIDE    : "/" >
| < EQUAL     : "=" >
| < AND       : "&&" >
| < LESS_THAN : "<" >
| < DOT       : "." >
| < NOT       : "!" >
}

// -----------------------------------------------------------------------------

TOKEN : /* SEPARATORS */
{
  < LPAR      : "(" >
| < RPAR      : ")" >
| < LBRACK    : "[" >
| < RBRACK    : "]" >
| < LBRACE    : "{" >
| < RBRACE    : "}" >
| < COMMA     : "," >
| < SEMICOLON : ";" >
}

// -----------------------------------------------------------------------------

TOKEN : /* METHODS */
{
  < PRINTLN : "System.out.println" >
}

// -----------------------------------------------------------------------------

TOKEN :
{
  < TYPE_INT       : "int" >
| < TYPE_BOOLEAN   : "boolean" >
| < TYPE_INT_ARRAY : < TYPE_INT > (< LBRACK > < RBRACK >)? >
| < TYPE           : < TYPE_INT >
                   | < TYPE_INT_ARRAY >
                   | < TYPE_BOOLEAN >
                   | < IDENTIFIER > >
| < CONSTANT       : (< DIGIT >)+ >
| < IDENTIFIER     : < LETTER > (< LETTER > | < DIGIT >)* >
| < #DIGIT         : [ "0"-"9" ] >
| < #LETTER        : [ "a"-"z" ] >
}

// -----------------------------------------------------------------------------

Program Program() :
{
  MainClass mainClass;
  ClassDecl c;
  ArrayList<ClassDecl> otherClasses = new ArrayList<ClassDecl>();
}
{
  mainClass=main()
  (
    c = classDeclaration()
    { otherClasses.add(c); }
  )*
  < EOF >
  { return new Program(mainClass, new NodeList<ClassDecl>(otherClasses)); }
}

// -----------------------------------------------------------------------------

MainClass main() : { Token t1; Token t2; Statement s; }
{
        < CLASS >
  t1 =  < IDENTIFIER >
        < LBRACE >
        < PUBLIC >
        < STATIC >
        < VOID >
        < MAIN >
        < LPAR >
        < STRING >
        < LBRACK >
        < RBRACK >
  t2 =  < IDENTIFIER >
        < RPAR >
        < LBRACE >
  s =   statement()
        < RBRACE >
        < RBRACE >
  { return new MainClass(t1.image, t2.image, s); }
}

// -----------------------------------------------------------------------------

ClassDecl classDeclaration() :
{
  Token t1;
  Token t2;
  NodeList<VarDecl> vars;
  NodeList<MethodDecl> methods;
}
{
  < CLASS >
  t1 = < IDENTIFIER >
  (
    < EXTENDS >
    t2 = < IDENTIFIER >
  )?
  < LBRACE >
  (
      vars = varDeclaration()
    | methods = methodDeclaration()
  )*
  < RBRACE >
  { return new ClassDecl(t1.image, t2.image, vars, methods); }
}

// -----------------------------------------------------------------------------

VarDecl varDeclaration() :
{
  Type type;
  Token id;
}
{
  type = Type()
  id = < IDENTIFIER >
  < SEMICOLON >
  { return new VarDecl(VarDecl.Kind.LOCAL, type, id.image); }
}

// -----------------------------------------------------------------------------

void methodDeclaration() :
{
  Type returnType;
  Token id;
  VarDecl varDecl;
  Statement s;
  ArrayList<VarDecl> formals = new ArrayList<VarDecl>();
  ArrayList<VarDecl> vars = new ArrayList<VarDecl>();
  ArrayList<Statement> statements = new ArrayList<Statement>();
  Expression returnExp;
}
{
  < PUBLIC >
  returnType = Type()
  id = < IDENTIFIER >
  < LPAR >
  formals = formalList()
  < RPAR >
  < LBRACE >
  (
    varDecl = varDeclaration()
    {      vars.add(varDecl);
    }
  )*
  (
    s = statement()
    {
      statements.add(s);
    }
  )*
  < RETURN >
  returnExp = Expression()
  < SEMICOLON >
  < RBRACE >
  { return new MethodDecl(returnType, id.image, formals, vars, statements, returnExp); }
}

// -----------------------------------------------------------------------------

ArrayList<VarDecl> formalList() :
{
  Type t;
  Token id;
  ArrayList<VarDecl> formals = new ArrayList<VarDecl>();
}
{
  (
    t = Type()
    id = < IDENTIFIER >
    {      formals.add(new VarDecl(VarDecl.Kind.FORMAL, t, id.image));
    }
    (
      < COMMA >
      t = Type()
      id = < IDENTIFIER >
      {
        formals.add(new VarDecl(VarDecl.Kind.FORMAL, t, id.image));
      }
    )*
  )?

  {    return formals;
  }
}

// -----------------------------------------------------------------------------

void statement() : {}
{
  < LBRACE > (statement())* < RBRACE >
| < IF > < LPAR > Expression() < RPAR > statement() < ELSE > statement()
| < WHILE > < LPAR > Expression() < RPAR > statement()
| < PRINTLN > < LPAR > Expression() < RPAR > < SEMICOLON >
| < IDENTIFIER > ((< EQUAL > Expression() < SEMICOLON >)
                  | (< LBRACK > Expression() < RBRACK > < EQUAL > Expression() < SEMICOLON >))
}

// -----------------------------------------------------------------------------

Expression Expression() : {}
{
/*  Expression() ( < AND > | < LESS_THAN > | < PLUS > | < MINUS > | < MULTIPLY > ) Expression()
| Expression() < LBRACK > Expression() < RBRACK >
| Expression() < DOT > < LENGTH >
| Expression() < DOT > < IDENTIFIER > < LPAR > ( Expression() ( < COMMA > Expression() )* )? < RPAR >
|*/ < CONSTANT >
| < TRUE >
| < FALSE >
| < IDENTIFIER >
| < THIS >
| < NEW > ( (< TYPE_INT > < LBRACK > Expression() < RBRACK >)
            | (< IDENTIFIER > < LPAR > < RPAR >))
| < NOT > Expression()
| < LPAR > Expression() < RPAR >
}

// -----------------------------------------------------------------------------

Type Type() :
{  Token t;
}
{  t = < TYPE >
  {
    switch(t.kind)
    {
      case TYPE_INT:
      	return new IntegerType();
      case TYPE_INT_ARRAY:
      	return new IntArrayType();
      case TYPE_BOOLEAN:
      	return new BooleanType();
      case IDENTIFIER:
      	return new ObjectType(t.image);
    }  }
}
